### Projeto de ComunicaÃ§Ã£o P2P com Protocolo Personalizado via UDP

Este projeto Ã© parte do **Trabalho 1 do LaboratÃ³rio de Redes de Computadores**, cujo objetivo Ã© desenvolver uma aplicaÃ§Ã£o distribuÃ­da de comunicaÃ§Ã£o entre dispositivos, utilizando **UDP e sockets**. Cada dispositivo implementa um protocolo personalizado para descoberta, troca de mensagens e envio confiÃ¡vel de arquivos.

## ğŸ“¦ Arquitetura e ExecuÃ§Ã£o com Docker Compose

O sistema Ã© composto por mÃºltiplos dispositivos (`device1`, `device2`, `device3`) simulados como containers Docker interconectados por uma rede virtual. Cada dispositivo roda uma instÃ¢ncia do programa com sua prÃ³pria identidade.

### âœ… PrÃ©-requisitos

- Docker
- Docker Compose

### â–¶ï¸ Como executar

1. Clone este repositÃ³rio e acesse a pasta do projeto:

```bash
git clone <repo-url>
cd <nome-do-projeto>
```

2. Construa e inicie os dispositivos:

```bash
docker-compose up --build
```

3. Acesse o terminal de um dispositivo (ex: device1):

```bash
docker exec -it <nome-do-container> bash
```

4. A interface de linha de comando estarÃ¡ ativa no terminal do container.

> Todos os arquivos devem ser colocados ou lidos a partir do diretÃ³rio `./arquivos` (que Ã© montado como `/app/files` nos containers).

---

Ou, para executar diretamente sem docker:

```bash
SERVER_PORT=9876 CLIENT_ID=device1 java -jar target/app.jar
```

---

## ğŸ›°ï¸ Funcionamento do Protocolo

### Descoberta automÃ¡tica

- Cada dispositivo envia uma mensagem `HEARTBEAT <nome>` via **broadcast** a cada 5 segundos.
- Os outros dispositivos escutam e mantÃªm uma lista atualizada dos dispositivos ativos.
- Se um dispositivo nÃ£o enviar heartbeat por **mais de 10 segundos**, ele serÃ¡ removido da lista.

### Tipos de mensagens

- `HEARTBEAT <nome>` â€“ Sinal de presenÃ§a na rede
- `TALK <id> <mensagem>` â€“ Mensagem entre pares com confirmaÃ§Ã£o (`ACK <id>`)
- `FILE <id> <nome-arquivo> <tamanho>` â€“ InÃ­cio da transferÃªncia de arquivo
- `CHUNK <id> <seq> <dados>` â€“ Bloco de dados codificado em base64
- `END <id> <hash>` â€“ Final da transferÃªncia com verificaÃ§Ã£o de integridade
- `ACK <id>` â€“ ConfirmaÃ§Ã£o de recebimento
- `NACK <id> <motivo>` â€“ RejeiÃ§Ã£o ou falha (ex: hash invÃ¡lido)

---

## ğŸ’» Interface de Linha de Comando (CLI)

A CLI estÃ¡ disponÃ­vel dentro de cada container e suporta os seguintes comandos:

### ğŸ”¹ `devices`

Lista os dispositivos ativos, mostrando:

- Nome
- EndereÃ§o IP e porta
- Tempo desde o Ãºltimo heartbeat

### ğŸ”¹ `talk <nome> <mensagem>`

Envia uma mensagem de texto para o dispositivo especificado. A CLI informa se o `ACK` foi recebido.

### ğŸ”¹ `sendfile <nome> <arquivo>`

Envia um arquivo (presente em `./arquivos`) para outro dispositivo:

- Mostra progresso da transferÃªncia (em blocos ou porcentagem)
- Realiza verificaÃ§Ã£o de integridade via hash SHA-256
- Tenta reenvio em caso de falha ou perda de pacotes

---

## ğŸ§ª Requisitos de Confiabilidade Implementados

- ConfirmaÃ§Ã£o com `ACK` e retransmissÃ£o
- DetecÃ§Ã£o de mensagens duplicadas
- VerificaÃ§Ã£o de ordem para `CHUNK`
- VerificaÃ§Ã£o de integridade com `END` + hash SHA-256
- TransferÃªncia em blocos (streaming), sem carregar o arquivo inteiro na memÃ³ria

---

## ğŸ—‚ï¸ OrganizaÃ§Ã£o dos arquivos

- Enviar: Coloque arquivos na pasta `./arquivos/`
- Receber: Os arquivos recebidos sÃ£o salvos com prefixo `received_<CLIENT_ID>_` em `/app/files`

---

ğŸ“ Projeto acadÃªmico â€” Redes de Computadores | Trabalho 1 | 2025
```
